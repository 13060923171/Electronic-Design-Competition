C51 COMPILER V8.02   MAIN                                                                  08/12/2009 11:15:29 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: F:\keil\UV3\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<reg51.h>
   2          sbit p1_0=P1^0;//电机旋转控制
   3          sbit p1_1=P1^1;//电机旋转控制
   4          sbit p1_2=P1^2;//电机使能控制
   5          sbit p1_3=P1^3;//电机旋转控制
   6          sbit p1_4=P1^4;//电机旋转控制
   7          sbit p1_5=P1^5;//电机使能控制
   8          sbit E_CLK=P1^6;//LCD显示。时钟输入
   9          sbit RW_SID=P1^7;//LCD显示。数据输入
  10          sbit p2_0=P2^0;//前进循迹方向信号
  11          sbit p2_1=P2^1;//前进循迹方向信号
  12          sbit p2_2=P2^2;//前进循迹方向信号
  13          sbit p2_3=P2^3;//跷跷板平衡信号
  14          sbit p2_4=P2^4;//跷跷板平衡信号
  15          sbit p2_5=P2^5;//跷跷板平衡信号
  16          sbit p2_6=P2^6;//后退循迹方向信号
  17          sbit p2_7=P2^7;//避障传感器信号
  18          sbit p3_2=P3^2;//温度传感器信号
  19          sbit p3_4=P3^4;//蜂鸣器信号控制
  20          sbit p3_6=P3^6;//状态切换键信号
  21          sbit p3_7=P3^7;//暂停/开始键信号
  22          
  23          
  24          /****************************************显示用变量*******************************************************
             -******/
  25          char sec1=48/*显示，秒十分位*/,sec2=48/*显示，秒个位*/,sec3=48/*显示，秒十位*/,sec4=48/*显示，秒百位*/;
  26          char sd1=48/*显示，速度十分位*/,sd2=48/*显示，速度个位*/,sd3=48/*显示，速度十位*/,sd4=48/*显示，速度百位*/
             -;
  27          char lc1=48/*显示，路程百分位*/,lc2=48/*显示，路程十分位*/,lc3=48/*显示，路程个位*/,lc4=48/*显示，路程十位
             -*/;
  28          int xszt1=0xD1/*显示，状态*/,xszt2=0xAD/*显示，状态*/,xszt3=0xBC/*显示，状态*/,xszt4=0xA3/*显示，状态*/;
  29          
  30          /****************************************跷跷板平衡用变量*************************************************
             -******/
  31          long qj=10/*前进参数*/,ht=1/*后退参数*/,tz=0/*平衡状态参数*/,bf=600/*步进*/;
  32          int cs=0/*跷跷板翻的次数*/,fdd=6/*防抖动系数*/,fx=0/*前一次运动方向，标志*/,ph=0/*平衡的持久度*/;
  33          int fy=0/*反应时间*/,cf=1/*冲锋标志*/,bc=0/*是否补偿,标志*/,phzt=0/*平衡状态*/,dd=0/*等待时间*/;
  34          
  35          /****************************************通用变量*********************************************************
             -*******/
  36          int a/**/,b/**/,l/**/,r/**/,i/**/,j,m=0/**/,k/**/,zt=1/*循迹、避障、平衡状态标志*/;
  37          int setnumber=8/*PWM占空比调整*/,n/*一秒种转了几圈*/,t/*计时用，每0.1秒判断标志，及时间传递显示的过度量*/;
  38          int tk/*时间计数*/,vt/*速度传递显示的过渡量*/,st/*路程传递显示的过渡量*/,yx/*小车运行标志*/,TC=1/*停车标志
             -*/;
  39          float s/*路程计算量*/,c=0.9742647/*轮子1/4圈的长度(cm)*/;
  40          double v/*速度计算量*/;
  41          
  42          #define uchar unsigned char
  43          #include<delay1ms.c>
  44          #include<xianshi.c>
  45          #include<xunji.c>
  46          #include<htxunji.c>
  47          #include<pheng.c>
  48          #include<bizhang1.c>
  49          #include<lcd3.c>
C51 COMPILER V8.02   MAIN                                                                  08/12/2009 11:15:29 PAGE 2   

  50          
  51          timer0() interrupt 1 using 1
  52          {       TH0=0xFc;
  53   1              TL0=0x18;
  54   1              r++;
  55   1              t++;
  56   1      if(TC==1)
  57   1      {       if(b==1)
  58   2              {
  59   3                      if(m<setnumber)
  60   3                      {       p1_2=0;
  61   4                              p1_5=0;
  62   4                      }
  63   3              else
  64   3                      {       p1_2=1;
  65   4                              p1_5=1;
  66   4                      }
  67   3              if (m>=10)
  68   3                      m=0;
  69   3                      m++;
  70   3              }
  71   2              else if(b==0)
  72   2              {               if(l<setnumber+1)
  73   3                      {       p1_2=0;
  74   4                              p1_5=0;
  75   4                      }
  76   3                      else
  77   3                      {       p1_2=1;
  78   4      
  79   4                      }
  80   3                      if (l>setnumber+2)
  81   3                      p1_5=1;
  82   3      
  83   3              if (l>10)
  84   3              l=0;
  85   3          l++;
  86   3              }
  87   2              }
  88   1                      if(t==100)
  89   1                      {               if(phzt!=1&&phzt!=3||zt!=3)
  90   2                                              tk++;
  91   2                                      else                     //若在状态3(跷跷板平衡状态)的平衡停表情况
  92   2                                              dd++;            //
  93   2                                      if(dd==50)               //
  94   2                                      {       if(phzt==1)      //
  95   3                                                      phzt=2;  //
  96   3                                              if(phzt==3)      //
  97   3                                                      phzt=4;  //打破平衡,准备下跷跷板
  98   3                                              tk=0;            //重新计时
  99   3                                              dd=0;
 100   3                                      }
 101   2      
 102   2                      if (tk>=10000)          //每
 103   2                              tk=0;                   //0.1
 104   2                      t=tk;                           //秒
 105   2                      sec4=(t/1000)+0x30;     //累
 106   2                      t=t%1000;                       //加
 107   2                      sec3=(t/100)+0x30;      //时
 108   2                      t=t%100;                        //间
 109   2                      sec2=(t/10)+0x30;       //一
 110   2                      t=t%10;                         //次
 111   2                      sec1=t+0x30;            //
C51 COMPILER V8.02   MAIN                                                                  08/12/2009 11:15:29 PAGE 3   

 112   2                      t=0;                            //
 113   2                      }
 114   1              if(r==1000)
 115   1                      {               r=0;                            //每
 116   2                                      v=n*c;                          //一
 117   2                                      v=v*10;                         //秒
 118   2                      vt=v;                           //计
 119   2                                      if(vt>=10000)           //算
 120   2                                      vt=9999;                        //速
 121   2                      sd4=(vt/1000)+0x30;     //度
 122   2                      vt=vt%1000;                     //一
 123   2                      sd3=(vt/100)+0x30;      //次
 124   2                      vt=vt%100;                      //
 125   2                      sd2=(vt/10)+0x30;       //
 126   2                      vt=vt%10;                       //
 127   2                      sd1=vt+0x30;            //
 128   2                                  n=0;                                //
 129   2                      }
 130   1      
 131   1      }
 132          
 133          
 134          timer1() interrupt 3 using 2
 135           {      if(a==3)                                        //在前进的时候。轮子每1/4周累加路程一次
 136   1                      {        n++;                           //在后退的时候。轮子每1/4周减少路程一次
 137   2                                      s=s+c;                          //
 138   2                       }                                                      //
 139   1                       else if(a==4)                          //
 140   1                                      s=s-c;                          //
 141   1                                      if(s>=10000||s<=0)      //
 142   1                                      s=0;                            //
 143   1                      st=s;                           //
 144   1                      lc4=(st/1000)+0x30;     //
 145   1                              st=st%1000;                     //
 146   1                      lc3=(st/100)+0x30;      //
 147   1                      st=st%100;                      //
 148   1                      lc2=(st/10)+0x30;       //
 149   1                      st=st%10;                       //
 150   1                      lc1=st+0x30;            //
 151   1                       
 152   1      }
 153          
 154          main()
 155          {       yx=0;/*是否运行,标志位*/
 156   1              kaiji();
 157   1              TMOD=0x61;       /**************************/
 158   1              TH0=0xFC;        /*                                            */
 159   1              TL0=0x18;        /*                        */
 160   1              TL1=-1;          /*定时计数器，装初值，打开*/
 161   1              TH1=-1;          /*                        */
 162   1              IP=0x08;         /*                        */
 163   1              EA=0;ET0=1;ET1=1;/*                        */
 164   1              TR0=1;TR1=1;     /**************************/ 
 165   1              initlcm();/*显示初始化*/   
 166   1              for(;;)
 167   1              {       xianshi();
 168   2                  if(p3_7==0)//暂停(启动)?
 169   2                         {
 170   3                                      yx++;     /*******************/
 171   3                                      yx=(yx%2);/*                 */
 172   3                                      EA=yx;    /*                 */
 173   3                                      TC=yx;    /*切换暂停/启动状态*/
C51 COMPILER V8.02   MAIN                                                                  08/12/2009 11:15:29 PAGE 4   

 174   3                                      p1_2=!yx; /*                 */
 175   3                                      p1_5=!yx; /*******************/
 176   3                                      delay1ms(50,1000);/*延时防抖动*/
 177   3                         }
 178   2                       if(p3_6==0)//切换状态？
 179   2                       {              yx=0;  //停
 180   3                                      EA=0;  //止
 181   3                                      TC=0;  //运
 182   3                                      p1_2=1;//行
 183   3                                      p1_5=1;//
 184   3                                      if(zt<3)  /**********/
 185   3                                              zt++; /*切换状态*/
 186   3                                      else zt=1;/**********/
 187   3                                      if(zt==1)
 188   3                                      {       xszt1=0xD1;//
 189   4                                              xszt2=0xAD;//切
 190   4                                              xszt3=0xBC;//换
 191   4                                              xszt4=0xA3;//显
 192   4                                      }                          //示
 193   3                                      if(zt==2)          //状
 194   3                                      {       xszt1=0xB1;//态
 195   4                                              xszt2=0xDC;//
 196   4                                              xszt3=0xD5;//
 197   4                                              xszt4=0xCF;//
 198   4                                      }                          //
 199   3                                      if(zt==3)          //
 200   3                                      {       xszt1=0xC6;//
 201   4                                              xszt2=0xBD;//
 202   4                                              xszt3=0xBA;//
 203   4                                              xszt4=0xE2;//
 204   4                                      }
 205   3                                      delay1ms(50,1000);/*延时防抖动*/
 206   3                       }
 207   2                       if(yx==1)//运行
 208   2                       {              if(zt==1)
 209   3                                              xunji();//状态1，则循迹
 210   3                                      else if(zt==2)
 211   3                                              bizhang();//状态2，则避障
 212   3                                      else if(zt==3)
 213   3                                              pheng();//状态3，则跷跷板平衡
 214   3                       }
 215   2              }
 216   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4065    ----
   CONSTANT SIZE    =    195    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =    100       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
